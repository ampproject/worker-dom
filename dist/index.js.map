{"version":3,"file":"index.js","sources":["../output/main-thread/strings.js","../output/main-thread/nodes.js","../output/main-thread/worker.js","../output/main-thread/command.js","../output/main-thread/hydrator.js","../output/main-thread/mutator.js","../output/main-thread/install.js","../output/main-thread/index.js"],"sourcesContent":["/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet count = 0;\nconst STRINGS = new Map();\n/**\n * Return a string for the specified index.\n * @param index string index to retrieve.\n * @returns string in map for the index.\n */\nexport function getString(index) {\n    return STRINGS.get(index) || '';\n}\n/**\n * Stores a string for parsing from mutation\n * @param value string to store from background thread.\n */\nexport function storeString(value) {\n    STRINGS.set(++count, value);\n}\n//# sourceMappingURL=strings.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getString } from './strings';\nlet NODES;\nlet BASE_ELEMENT;\nexport function prepare(baseElement) {\n    NODES = new Map([[1, baseElement], [2, baseElement]]);\n    BASE_ELEMENT = baseElement;\n}\nexport function isTextNode(node) {\n    return ('nodeType' in node ? node.nodeType : node[0 /* nodeType */]) === 3 /* TEXT_NODE */;\n}\n/**\n * Create a real DOM Node from a skeleton Object (`{ nodeType, nodeName, attributes, children, data }`)\n * @example <caption>Text node</caption>\n *   createNode({ nodeType:3, data:'foo' })\n * @example <caption>Element node</caption>\n *   createNode({ nodeType:1, nodeName:'div', attributes:[{ name:'a', value:'b' }], childNodes:[ ... ] })\n */\nexport function createNode(skeleton) {\n    if (isTextNode(skeleton)) {\n        const node = document.createTextNode(getString(skeleton[5 /* textContent */]));\n        storeNode(node, skeleton[7 /* _index_ */]);\n        return node;\n    }\n    const namespace = skeleton[6 /* namespaceURI */] !== undefined ? getString(skeleton[6 /* namespaceURI */]) : undefined;\n    const node = namespace\n        ? document.createElementNS(namespace, getString(skeleton[1 /* nodeName */]))\n        : document.createElement(getString(skeleton[1 /* nodeName */]));\n    // TODO(KB): Restore Properties\n    // skeleton.properties.forEach(property => {\n    //   node[`${property.name}`] = property.value;\n    // });\n    // ((skeleton as TransferrableElement)[TransferrableKeys.childNodes] || []).forEach(childNode => {\n    //   if (childNode[TransferrableKeys.transferred] === NumericBoolean.FALSE) {\n    //     node.appendChild(createNode(childNode as TransferrableNode));\n    //   }\n    // });\n    storeNode(node, skeleton[7 /* _index_ */]);\n    return node;\n}\n/**\n * Returns the real DOM Element corresponding to a serialized Element object.\n * @param id\n * @return\n */\nexport function getNode(id) {\n    const node = NODES.get(id);\n    if (node && node.nodeName === 'BODY') {\n        // If the node requested is the \"BODY\"\n        // Then we return the base node this specific <amp-script> comes from.\n        // This encapsulates each <amp-script> node.\n        return BASE_ELEMENT;\n    }\n    return node;\n}\n/**\n * Establish link between DOM `node` and worker-generated identifier `id`.\n *\n * These _shouldn't_ collide between instances of <amp-script> since\n * each element creates it's own pool on both sides of the worker\n * communication bridge.\n * @param node\n * @param id\n */\nexport function storeNode(node, id) {\n    node._index_ = id;\n    NODES.set(id, node);\n}\n//# sourceMappingURL=nodes.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(KB): Fetch Polyfill for IE11.\nexport function createWorker(workerDomURL, authorScriptURL) {\n    return Promise.all([fetch(workerDomURL).then(response => response.text()), fetch(authorScriptURL).then(response => response.text())])\n        .then(([workerScript, authorScript]) => {\n        // TODO(KB): Minify this output during build process.\n        const keys = [];\n        for (let key in document.body.style) {\n            keys.push(`'${key}'`);\n        }\n        const code = `\n        'use strict';\n        ${workerScript}\n        (function() {\n          var self = this;\n          var window = this;\n          var document = this.document;\n          var localStorage = this.localStorage;\n          var location = this.location;\n          var defaultView = document.defaultView;\n          var Node = defaultView.Node;\n          var Text = defaultView.Text;\n          var Element = defaultView.Element;\n          var SVGElement = defaultView.SVGElement;\n          var Document = defaultView.Document;\n          var Event = defaultView.Event;\n          var MutationObserver = defaultView.MutationObserver;\n\n          function addEventListener(type, handler) {\n            return document.addEventListener(type, handler);\n          }\n          function removeEventListener(type, handler) {\n            return document.removeEventListener(type, handler);\n          }\n          this.appendKeys([${keys}]);\n          ${authorScript}\n        }).call(WorkerThread.workerDOM);\n//# sourceURL=${encodeURI(authorScriptURL)}`;\n        return new Worker(URL.createObjectURL(new Blob([code])));\n    })\n        .catch(error => {\n        return null;\n    });\n}\nexport function messageToWorker(worker, message) {\n    worker.postMessage(message);\n}\n//# sourceMappingURL=worker.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { messageToWorker } from './worker';\nimport { getNode } from './nodes';\nimport { getString } from './strings';\nconst KNOWN_LISTENERS = [];\n/**\n * Instead of a whitelist of elements that need their value tracked, use the existence\n * of a property called value to drive the decision.\n * @param node node to check if values should be tracked.\n * @return boolean if the node should have its value property tracked.\n */\nconst shouldTrackChanges = (node) => node && 'value' in node;\n/**\n * When a node that has a value needing synced doesn't already have an event listener\n * listening for changed values, ensure the value is synced with a default listener.\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const applyDefaultChangeListener = (worker, node) => {\n    shouldTrackChanges(node) && node.onchange === null && (node.onchange = () => fireValueChange(worker, node));\n};\n/**\n * Tell the worker DOM what the value is for a Node.\n * @param worker whom to dispatch value toward.\n * @param node where to get the value from.\n */\nconst fireValueChange = (worker, node) => {\n    messageToWorker(worker, {\n        [9 /* type */]: 5 /* SYNC */,\n        [38 /* sync */]: {\n            [7 /* _index_ */]: node._index_,\n            [18 /* value */]: node.value,\n        },\n    });\n};\n/**\n * Register an event handler for dispatching events to worker thread\n * @param worker whom to dispatch events toward\n * @param _index_ node index the event comes from (used to dispatchEvent in worker thread).\n * @return eventHandler function consuming event and dispatching to worker thread\n */\nconst eventHandler = (worker, _index_) => (event) => {\n    if (shouldTrackChanges(event.currentTarget)) {\n        fireValueChange(worker, event.currentTarget);\n    }\n    messageToWorker(worker, {\n        [9 /* type */]: 1 /* EVENT */,\n        [37 /* event */]: {\n            [7 /* _index_ */]: _index_,\n            [22 /* bubbles */]: event.bubbles,\n            [23 /* cancelable */]: event.cancelable,\n            [24 /* cancelBubble */]: event.cancelBubble,\n            [25 /* currentTarget */]: {\n                [7 /* _index_ */]: event.currentTarget._index_,\n                [8 /* transferred */]: 1 /* TRUE */,\n            },\n            [26 /* defaultPrevented */]: event.defaultPrevented,\n            [27 /* eventPhase */]: event.eventPhase,\n            [28 /* isTrusted */]: event.isTrusted,\n            [29 /* returnValue */]: event.returnValue,\n            [10 /* target */]: {\n                [7 /* _index_ */]: event.target._index_,\n                [8 /* transferred */]: 1 /* TRUE */,\n            },\n            [30 /* timeStamp */]: event.timeStamp,\n            [9 /* type */]: event.type,\n            [32 /* keyCode */]: 'keyCode' in event ? event.keyCode : undefined,\n        },\n    });\n};\n/**\n * Process commands transfered from worker thread to main thread.\n * @param nodesInstance nodes instance to execute commands against.\n * @param worker whom to dispatch events toward.\n * @param mutation mutation record containing commands to execute.\n */\nexport function process(worker, mutation) {\n    const _index_ = mutation[10 /* target */];\n    const target = getNode(_index_);\n    (mutation[21 /* removedEvents */] || []).forEach(eventSub => {\n        processListenerChange(worker, target, false, getString(eventSub[9 /* type */]), eventSub[33 /* index */]);\n    });\n    (mutation[20 /* addedEvents */] || []).forEach(eventSub => {\n        processListenerChange(worker, target, true, getString(eventSub[9 /* type */]), eventSub[33 /* index */]);\n    });\n}\n/**\n * If the worker requests to add an event listener to 'change' for something the foreground thread is already listening to\n * ensure that only a single 'change' event is attached to prevent sending values multiple times.\n * @param worker worker issuing listener changes\n * @param target node to change listeners on\n * @param addEvent is this an 'addEvent' or 'removeEvent' change\n * @param type event type requested to change\n * @param index number in the listeners array this event corresponds to.\n */\nexport function processListenerChange(worker, target, addEvent, type, index) {\n    let changeEventSubscribed = target.onchange !== null;\n    const shouldTrack = shouldTrackChanges(target);\n    const isChangeEvent = type === 'change';\n    if (addEvent) {\n        if (isChangeEvent) {\n            changeEventSubscribed = true;\n            target.onchange = null;\n        }\n        target.addEventListener(type, (KNOWN_LISTENERS[index] = eventHandler(worker, target._index_)));\n    }\n    else {\n        if (isChangeEvent) {\n            changeEventSubscribed = false;\n        }\n        target.removeEventListener(type, KNOWN_LISTENERS[index]);\n    }\n    if (shouldTrack && !changeEventSubscribed) {\n        applyDefaultChangeListener(worker, target);\n    }\n}\n//# sourceMappingURL=command.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { storeNode, getNode, createNode, isTextNode } from './nodes';\nimport { storeString, getString } from './strings';\nimport { applyDefaultChangeListener, processListenerChange } from './command';\nfunction allTextNodes(nodes) {\n    return nodes.length > 0 && [].every.call(nodes, isTextNode);\n}\n/**\n * Replace all the children with the ones from the HydrateableNode.\n * Used when we're certain the content won't break the page.\n * @param nodes HydrateableNodes containing content to potentially overwrite main thread content.\n * @param parent Node in the main thread that will be the parent of the passed nodes.\n * @param worker worker that issued the request for hydration.\n */\nfunction replaceNodes(nodes, parent, worker) {\n    [].forEach.call(parent.childNodes, (childNode) => childNode.remove());\n    nodes.forEach((node, index) => {\n        const newNode = createNode(node);\n        (node[2 /* attributes */] || []).forEach(attribute => {\n            const namespaceURI = getString(attribute[0]);\n            if (namespaceURI !== 'null') {\n                newNode.setAttributeNS(namespaceURI, getString(attribute[1]), getString(attribute[2]));\n            }\n            else {\n                newNode.setAttribute(getString(attribute[1]), getString(attribute[2]));\n            }\n        });\n        parent.appendChild(newNode);\n        applyDefaultChangeListener(worker, newNode);\n        replaceNodes(node[4 /* childNodes */] || [], parent.childNodes[index], worker);\n    });\n}\n/**\n * Hydrate a single node and it's children safely.\n * Attempt to ensure content is a rough match so content doesn't shift between the document representation\n * and client side generated content.\n * @param transferNode root of the background thread content (document.body from worker-thread).\n * @param node root for the foreground thread content (element upgraded to background driven).\n * @param worker worker that issued the request for hydration.\n */\nfunction hydrateNode(transferNode, node, worker) {\n    const transferIsText = isTextNode(transferNode);\n    const nodeIsText = isTextNode(node);\n    if (!transferIsText && !nodeIsText) {\n        const childNodes = transferNode[4 /* childNodes */] || [];\n        if (childNodes.length !== node.childNodes.length) {\n            // If this parent node has an unequal number of childNodes, we need to ensure its for an allowable reason.\n            if (allTextNodes(childNodes) && allTextNodes(node.childNodes)) {\n                // Offset due to a differing number of text nodes.\n                // replace the current DOM with the text nodes from the hydration.\n                replaceNodes(childNodes, node, worker);\n            }\n            else {\n                const filteredTransfer = childNodes.filter(childNode => !isTextNode(childNode));\n                const filteredNodes = [].filter.call(node.childNodes, (childNode) => !isTextNode(childNode));\n                // Empty text nodes are used by frameworks as placeholders for future dom content.\n                if (filteredTransfer.length === filteredNodes.length) {\n                    storeNode(node, transferNode[7 /* _index_ */]);\n                    replaceNodes(childNodes, node, worker);\n                }\n            }\n        }\n        else {\n            storeNode(node, transferNode[7 /* _index_ */]);\n            applyDefaultChangeListener(worker, node);\n            // Same number of children, hydrate them.\n            childNodes.forEach((childNode, index) => hydrateNode(childNode, node.childNodes[index], worker));\n        }\n    }\n    else if (transferIsText && nodeIsText) {\n        // Singular text node, no children.\n        storeNode(node, transferNode[7 /* _index_ */]);\n        node.textContent = getString(transferNode[5 /* textContent */]);\n        applyDefaultChangeListener(worker, node);\n    }\n}\n/**\n * Hydrate a root from the worker thread by comparing with the main thread representation.\n * @param skeleton root of the background thread content.\n * @param addEvents events needing subscription from the background thread content.\n * @param baseElement root of the main thread content to compare against.\n * @param worker worker issuing the upgrade request.\n */\nexport function hydrate(skeleton, stringValues, addEvents, baseElement, worker) {\n    // Process String Additions\n    stringValues.forEach(value => storeString(value));\n    // Process Node Addition / Removal\n    hydrateNode(skeleton, baseElement, worker);\n    // Process Event Addition\n    addEvents.forEach(event => {\n        const node = getNode(event[7 /* _index_ */]);\n        node && processListenerChange(worker, node, true, getString(event[9 /* type */]), event[33 /* index */]);\n    });\n}\n//# sourceMappingURL=hydrator.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNode, createNode } from './nodes';\nimport { storeString, getString } from './strings';\nimport { process } from './command';\nlet MUTATION_QUEUE = [];\nlet PENDING_MUTATIONS = false;\nlet worker;\nexport function prepareMutate(passedWorker) {\n    worker = passedWorker;\n}\nconst mutators = {\n    [2 /* CHILD_LIST */](mutation, target, sanitizer) {\n        (mutation[12 /* removedNodes */] || []).forEach(node => getNode(node[7 /* _index_ */]).remove());\n        const addedNodes = mutation[11 /* addedNodes */];\n        const nextSibling = mutation[14 /* nextSibling */];\n        if (addedNodes) {\n            addedNodes.forEach(node => {\n                let newChild = getNode(node[7 /* _index_ */]);\n                if (!newChild) {\n                    newChild = createNode(node);\n                    if (sanitizer) {\n                        sanitizer.sanitize(newChild); // TODO(choumx): Inform worker?\n                    }\n                }\n                target.insertBefore(newChild, (nextSibling && getNode(nextSibling[7 /* _index_ */])) || null);\n            });\n        }\n    },\n    [0 /* ATTRIBUTES */](mutation, target, sanitizer) {\n        const attributeName = mutation[15 /* attributeName */] !== undefined ? getString(mutation[15 /* attributeName */]) : null;\n        const value = mutation[18 /* value */] !== undefined ? getString(mutation[18 /* value */]) : null;\n        if (attributeName != null && value != null) {\n            if (!sanitizer || sanitizer.validAttribute(target.nodeName, attributeName, value)) {\n                target.setAttribute(attributeName, value);\n            }\n            else {\n                // TODO(choumx): Inform worker?\n            }\n        }\n    },\n    [1 /* CHARACTER_DATA */](mutation, target) {\n        const value = mutation[18 /* value */];\n        if (value) {\n            // Sanitization not necessary for textContent.\n            target.textContent = getString(value);\n        }\n    },\n    [3 /* PROPERTIES */](mutation, target, sanitizer) {\n        const propertyName = mutation[17 /* propertyName */] !== undefined ? getString(mutation[17 /* propertyName */]) : null;\n        const value = mutation[18 /* value */] !== undefined ? getString(mutation[18 /* value */]) : null;\n        if (propertyName && value) {\n            if (!sanitizer || sanitizer.validProperty(target.nodeName, propertyName, value)) {\n                target[propertyName] = value;\n            }\n            else {\n                // TODO(choumx): Inform worker?\n            }\n        }\n    },\n    [4 /* COMMAND */](mutation) {\n        process(worker, mutation);\n    },\n};\n/**\n * Process MutationRecords from worker thread applying changes to the existing DOM.\n * @param nodes New nodes to add in the main thread with the incoming mutations.\n * @param mutations Changes to apply in both graph shape and content of Elements.\n * @param sanitizer Sanitizer to apply to content if needed.\n */\nexport function mutate(nodes, stringValues, mutations, sanitizer) {\n    //mutations: TransferrableMutationRecord[]): void {\n    // TODO(KB): Restore signature requiring lastMutationTime. (lastGestureTime: number, mutations: TransferrableMutationRecord[])\n    // if (performance.now() || Date.now() - lastGestureTime > GESTURE_TO_MUTATION_THRESHOLD) {\n    //   return;\n    // }\n    // this.lastGestureTime = lastGestureTime;\n    stringValues.forEach(value => storeString(value));\n    nodes.forEach(node => createNode(node));\n    MUTATION_QUEUE = MUTATION_QUEUE.concat(mutations);\n    if (!PENDING_MUTATIONS) {\n        PENDING_MUTATIONS = true;\n        requestAnimationFrame(() => syncFlush(sanitizer));\n    }\n}\n/**\n * Apply all stored mutations syncronously. This method works well, but can cause jank if there are too many\n * mutations to apply in a single frame.\n *\n * Investigations in using asyncFlush to resolve are worth considering.\n */\nfunction syncFlush(sanitizer) {\n    MUTATION_QUEUE.forEach(mutation => {\n        mutators[mutation[9 /* type */]](mutation, getNode(mutation[10 /* target */]), sanitizer);\n    });\n    MUTATION_QUEUE = [];\n    PENDING_MUTATIONS = false;\n}\n//# sourceMappingURL=mutator.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { hydrate } from './hydrator';\nimport { prepareMutate, mutate } from './mutator';\nimport { createWorker } from './worker';\nimport { prepare as prepareNodes } from './nodes';\nexport function install(baseElement, workerDOMUrl, sanitizer) {\n    const authorURL = baseElement.getAttribute('src');\n    if (authorURL === null) {\n        return;\n    }\n    createWorker(workerDOMUrl, authorURL).then(worker => {\n        if (worker === null) {\n            return;\n        }\n        prepareNodes(baseElement);\n        prepareMutate(worker);\n        worker.onmessage = ({ data }) => {\n            switch (data[9 /* type */]) {\n                case 2 /* HYDRATE */:\n                    // console.info(`hydration from worker: ${data.type}`, data);\n                    hydrate(data[35 /* nodes */], data[39 /* strings */], data[20 /* addedEvents */], baseElement, worker);\n                    break;\n                case 3 /* MUTATE */:\n                    // console.info(`mutation from worker: ${data.type}`, data);\n                    mutate(data[35 /* nodes */], data[39 /* strings */], data[34 /* mutations */], sanitizer);\n                    break;\n            }\n        };\n    });\n}\n//# sourceMappingURL=install.js.map","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { install } from './install';\nexport function upgradeElement(baseElement, workerDOMUrl) {\n    install(baseElement, workerDOMUrl);\n}\n//# sourceMappingURL=index.js.map"],"names":["getString","index","STRINGS","get","prepare","baseElement","NODES","Map","BASE_ELEMENT","isTextNode","node","nodeType","createNode","skeleton","_node","document","createTextNode","storeNode","namespace","undefined","createElementNS","createElement","getNode","id","nodeName","_index_","set","createWorker","workerDomURL","authorScriptURL","Promise","all","fetch","then","response","text","workerScript","authorScript","keys","key","body","style","push","code","encodeURI","Worker","URL","createObjectURL","Blob","catch","error","process","worker","mutation","target","eventSub","processListenerChange","addEvent","type","changeEventSubscribed","onchange","shouldTrack","shouldTrackChanges","isChangeEvent","addEventListener","KNOWN_LISTENERS","eventHandler","removeEventListener","applyDefaultChangeListener","allTextNodes","nodes","length","every","call","replaceNodes","parent","childNodes","childNode","remove","forEach","newNode","attribute","namespaceURI","setAttributeNS","setAttribute","appendChild","hydrateNode","transferNode","transferIsText","nodeIsText","textContent","filteredTransfer","filter","filteredNodes","hydrate","stringValues","addEvents","value","count","event","mutate","mutations","sanitizer","MUTATION_QUEUE","concat","PENDING_MUTATIONS","requestAnimationFrame","syncFlush","mutators","install","workerDOMUrl","authorURL","getAttribute","prepareNodes","onmessage","worker.onmessage","data","node.onchange","fireValueChange","postMessage","message","currentTarget","bubbles","cancelable","cancelBubble","defaultPrevented","eventPhase","isTrusted","returnValue","timeStamp","keyCode","addedNodes","nextSibling","newChild","sanitize","insertBefore","attributeName","validAttribute","propertyName","validProperty","upgradeElement"],"mappings":"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"}